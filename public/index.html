<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>読みたいものリスト 🔥</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo } = React;

        const App = () => {
            const [urlItems, setUrlItems] = useState([]);
            const [filterGenre, setFilterGenre] = useState('すべて');
            const [readStatusFilter, setReadStatusFilter] = useState('すべて');
            const [sortBy, setSortBy] = useState('created');
            const [sortDirection, setSortDirection] = useState('desc');
            const [searchQuery, setSearchQuery] = useState('');
            const [showSettings, setShowSettings] = useState(false);
            const [apiKey, setApiKey] = useState('');

            // ユーザーID生成・取得
            const getUserId = useCallback(() => {
                let userId = localStorage.getItem('userId');
                if (!userId) {
                    userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('userId', userId);
                }
                return userId;
            }, []);

            // APIキー管理
            useEffect(() => {
                const savedApiKey = localStorage.getItem('openai_api_key');
                if (savedApiKey) {
                    try {
                        const decryptedKey = atob(savedApiKey);
                        setApiKey(decryptedKey);
                        console.log('OpenAI API Key loaded successfully');
                    } catch (error) {
                        console.error('Failed to load API key:', error);
                    }
                }
            }, []);

            const saveApiKey = useCallback((key) => {
                try {
                    const encryptedKey = btoa(key);
                    localStorage.setItem('openai_api_key', encryptedKey);
                    setApiKey(key);
                    console.log('OpenAI API Key saved successfully');
                } catch (error) {
                    console.error('Failed to save API key:', error);
                }
            }, []);

            // URLコンテンツ取得（CORSプロキシ使用）
            const fetchUrlContent = useCallback(async (url) => {
                try {
                    console.log('Fetching content from URL:', url);
                    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                    const response = await fetch(proxyUrl);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const html = data.contents;
                    
                    // HTMLからテキストコンテンツを抽出
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // title要素を取得
                    const title = doc.querySelector('title')?.textContent || '';
                    
                    // メタディスクリプションを取得
                    const metaDescription = doc.querySelector('meta[name="description"]')?.getAttribute('content') || '';
                    
                    // 主要なテキストコンテンツを取得（スクリプト、スタイルを除外）
                    const scripts = doc.querySelectorAll('script, style, nav, footer, header');
                    scripts.forEach(script => script.remove());
                    
                    const bodyText = doc.body?.textContent || doc.textContent || '';
                    const cleanText = bodyText.replace(/\s+/g, ' ').trim().substring(0, 3000);
                    
                    console.log('Content extraction successful:', {
                        title: title.substring(0, 100),
                        description: metaDescription.substring(0, 100),
                        content: cleanText.substring(0, 200)
                    });
                    
                    return {
                        title,
                        description: metaDescription,
                        content: cleanText
                    };
                } catch (error) {
                    console.error('Content fetch error:', error);
                    throw error;
                }
            }, []);

            // AI分析機能
            const analyzeWithAI = useCallback(async (content, originalTitle) => {
                if (!apiKey) {
                    console.warn('No API key configured for AI analysis');
                    return originalTitle || 'Webページ';
                }

                try {
                    console.log('Analyzing with AI...');
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [
                                {
                                    role: 'system',
                                    content: 'あなたはWebページの内容を分析して、分かりやすいタイトルを生成する専門家です。ページの内容を理解し、全角120文字以内で、そのページが何について書かれているのかを明確に説明するタイトルを生成してください。技術的すぎず、一般の人にも理解しやすい言葉を使ってください。'
                                },
                                {
                                    role: 'user',
                                    content: `以下のWebページ内容を分析して、内容が分かりやすいタイトルを全角120文字以内で生成してください。

元のタイトル: ${originalTitle}
メタディスクリプション: ${content.description}
ページ内容: ${content.content}

生成するタイトルは、このページが何について書かれているのか、どんな情報が得られるのかを明確に説明してください。`
                                }
                            ],
                            max_tokens: 150,
                            temperature: 0.3
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.text();
                        console.error('OpenAI API error:', response.status, errorData);
                        throw new Error(`OpenAI API error: ${response.status}`);
                    }

                    const data = await response.json();
                    const generatedTitle = data.choices[0]?.message?.content?.trim();
                    
                    if (generatedTitle) {
                        console.log('AI analysis completed successfully:', generatedTitle);
                        // 120文字制限を確実に適用
                        return generatedTitle.length > 120 ? generatedTitle.substring(0, 120) : generatedTitle;
                    } else {
                        console.warn('No generated title received from AI');
                        return originalTitle || 'Webページ';
                    }
                } catch (error) {
                    console.error('AI analysis error:', error);
                    return originalTitle || 'Webページ';
                }
            }, [apiKey]);

            // URLメタデータ取得（AI分析対応）
            const fetchUrlMetadata = useCallback(async (url) => {
                try {
                    console.log('Starting metadata fetch for:', url);
                    
                    // URLからドメイン情報を取得
                    const urlObj = new URL(url);
                    const domain = urlObj.hostname.toLowerCase();
                    
                    // ドメインベースでのアイコン生成
                    let thumbnail = '';
                    if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                        thumbnail = '🎥';
                    } else if (domain.includes('github.com')) {
                        thumbnail = '💻';
                    } else if (domain.includes('qiita.com')) {
                        thumbnail = '📝';
                    } else if (domain.includes('note.com') || domain.includes('medium.com')) {
                        thumbnail = '✍️';
                    } else if (domain.includes('twitter.com') || domain.includes('x.com')) {
                        thumbnail = '🐦';
                    } else if (domain.includes('amazon.co.jp') || domain.includes('amazon.com')) {
                        thumbnail = '🛒';
                    } else if (domain.includes('wikipedia.org')) {
                        thumbnail = '📚';
                    } else if (domain.includes('news') || domain.includes('nikkei') || domain.includes('asahi') || domain.includes('mainichi')) {
                        thumbnail = '📰';
                    } else {
                        thumbnail = '🌐';
                    }

                    // APIキーが設定されている場合はAI分析を実行
                    if (apiKey) {
                        try {
                            const content = await fetchUrlContent(url);
                            const aiTitle = await analyzeWithAI(content, content.title);
                            
                            return { 
                                title: aiTitle, 
                                thumbnail, 
                                domain: urlObj.hostname 
                            };
                        } catch (error) {
                            console.warn('AI analysis failed, falling back to simple title:', error);
                            // AI分析失敗時は従来の方法にフォールバック
                        }
                    }

                    // フォールバック：シンプルなタイトル生成
                    let fallbackTitle = '';
                    if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                        fallbackTitle = 'YouTube動画';
                    } else if (domain.includes('github.com')) {
                        fallbackTitle = 'GitHub リポジトリ';
                    } else if (domain.includes('qiita.com')) {
                        fallbackTitle = 'Qiita記事';
                    } else if (domain.includes('note.com') || domain.includes('medium.com')) {
                        fallbackTitle = 'ブログ記事';
                    } else if (domain.includes('twitter.com') || domain.includes('x.com')) {
                        fallbackTitle = 'Twitter/X投稿';
                    } else if (domain.includes('amazon.co.jp') || domain.includes('amazon.com')) {
                        fallbackTitle = 'Amazon商品';
                    } else if (domain.includes('wikipedia.org')) {
                        fallbackTitle = 'Wikipedia記事';
                    } else if (domain.includes('news') || domain.includes('nikkei') || domain.includes('asahi') || domain.includes('mainichi')) {
                        fallbackTitle = 'ニュース記事';
                    } else {
                        fallbackTitle = `${domain.replace('www.', '')}のページ`;
                    }
                    
                    return { title: fallbackTitle, thumbnail, domain: urlObj.hostname };
                } catch (error) {
                    console.error('Metadata fetch error:', error);
                    return { title: 'Webページ', thumbnail: '🌐', domain: '' };
                }
            }, [apiKey, fetchUrlContent, analyzeWithAI]);

            // 自動ジャンル分類
            const classifyGenre = useCallback((url, title) => {
                const urlLower = url.toLowerCase();
                const titleLower = title.toLowerCase();
                const combined = (urlLower + ' ' + titleLower).toLowerCase();
                
                // プログラミング・技術系
                if (combined.includes('github') || combined.includes('qiita') || combined.includes('stack') || 
                    combined.includes('programming') || combined.includes('code') || combined.includes('tech') ||
                    combined.includes('javascript') || combined.includes('python') || combined.includes('react') ||
                    combined.includes('プログラミング') || combined.includes('技術') || combined.includes('開発') ||
                    combined.includes('コード') || combined.includes('api') || combined.includes('framework')) {
                    return '技術・プログラミング';
                }
                
                // ニュース
                if (combined.includes('news') || combined.includes('nikkei') || combined.includes('asahi') || 
                    combined.includes('mainichi') || combined.includes('reuters') || combined.includes('cnn') ||
                    combined.includes('ニュース') || combined.includes('新聞') || combined.includes('報道')) {
                    return 'ニュース';
                }
                
                // エンターテイメント
                if (combined.includes('youtube') || combined.includes('netflix') || combined.includes('movie') || 
                    combined.includes('music') || combined.includes('game') || combined.includes('anime') ||
                    combined.includes('entertainment') || combined.includes('エンタメ') || combined.includes('映画') ||
                    combined.includes('音楽') || combined.includes('ゲーム') || combined.includes('アニメ')) {
                    return 'エンターテイメント';
                }
                
                // 教育・学習
                if (combined.includes('wikipedia') || combined.includes('coursera') || combined.includes('udemy') || 
                    combined.includes('education') || combined.includes('learn') || combined.includes('study') ||
                    combined.includes('教育') || combined.includes('学習') || combined.includes('勉強') ||
                    combined.includes('講座') || combined.includes('tutorial')) {
                    return '教育・学習';
                }
                
                // ビジネス
                if (combined.includes('business') || combined.includes('marketing') || combined.includes('startup') || 
                    combined.includes('finance') || combined.includes('investment') || combined.includes('economy') ||
                    combined.includes('ビジネス') || combined.includes('マーケティング') || combined.includes('投資') ||
                    combined.includes('経済') || combined.includes('金融') || combined.includes('起業')) {
                    return 'ビジネス';
                }
                
                // ショッピング
                if (combined.includes('amazon') || combined.includes('rakuten') || combined.includes('shop') || 
                    combined.includes('buy') || combined.includes('product') || combined.includes('price') ||
                    combined.includes('ショッピング') || combined.includes('買い物') || combined.includes('商品')) {
                    return 'ショッピング';
                }
                
                // ブログ・記事
                if (combined.includes('blog') || combined.includes('article') || combined.includes('note.com') || 
                    combined.includes('medium.com') || combined.includes('ブログ') || combined.includes('記事') ||
                    combined.includes('コラム')) {
                    return 'ブログ・記事';
                }
                
                return '未分類';
            }, []);

            // LocalStorageからデータを読み込み
            useEffect(() => {
                try {
                    const userData = localStorage.getItem('userData');
                    if (userData) {
                        const data = JSON.parse(userData);
                        if (data.urlItems && Array.isArray(data.urlItems)) {
                            const migratedItems = data.urlItems.map(item => ({
                                ...item,
                                comment: item.comment || '',
                                title: item.title || '',
                                thumbnail: item.thumbnail || '🌐',
                                domain: item.domain || ''
                            }));
                            setUrlItems(migratedItems.filter(item => item.url));
                            return;
                        }
                    }

                    const storedItems = localStorage.getItem('urlItems');
                    if (storedItems) {
                        const parsedItems = JSON.parse(storedItems);
                        const migratedItems = parsedItems.map(item => ({
                            id: item.id || new Date().toISOString(),
                            url: item.url || '',
                            isRead: item.isRead || false,
                            rating: item.rating || 0,
                            priority: item.priority || 0,
                            genre: item.genre || '未分類',
                            createdAt: item.createdAt || new Date().toISOString(),
                            comment: item.comment || '',
                            title: item.title || '',
                            thumbnail: item.thumbnail || '🌐',
                            domain: item.domain || ''
                        }));
                        setUrlItems(migratedItems.filter(item => item.url));
                    }
                } catch (error) {
                    console.error("Failed to load items from localStorage", error);
                }
            }, []);

            // LocalStorageにデータを保存
            useEffect(() => {
                try {
                    const userId = getUserId();
                    const userData = {
                        userId: userId,
                        urlItems: urlItems,
                        lastModified: new Date().toISOString(),
                        appVersion: '2.8'
                    };
                    
                    localStorage.setItem('userData', JSON.stringify(userData));
                    localStorage.setItem('urlItems', JSON.stringify(urlItems));
                } catch (error) {
                    console.error("Failed to save items to localStorage", error);
                }
            }, [urlItems, getUserId]);

            // エクスポート機能
            const exportData = useCallback(() => {
                const userId = getUserId();
                const exportData = {
                    userId: userId,
                    urlItems: urlItems,
                    exportDate: new Date().toISOString(),
                    appVersion: '2.8',
                    totalItems: urlItems.length
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `website-list-${userId.substr(-8)}-${new Date().toISOString().substr(0,10)}.json`;
                link.click();
                
                alert(`${urlItems.length}件のWebサイトをエクスポートしました！`);
            }, [urlItems, getUserId]);

            // インポート機能
            const importData = useCallback((event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (importedData.urlItems && Array.isArray(importedData.urlItems)) {
                            const confirmMessage = `${importedData.urlItems.length}件のWebサイトをインポートしますか？\n現在のデータは上書きされます。`;
                            
                            if (confirm(confirmMessage)) {
                                const migratedItems = importedData.urlItems.map(item => ({
                                    ...item,
                                    comment: item.comment || '',
                                    title: item.title || '',
                                    thumbnail: item.thumbnail || '🌐',
                                    domain: item.domain || ''
                                }));
                                setUrlItems(migratedItems);
                                alert('データのインポートが完了しました！');
                            }
                        } else {
                            alert('無効なファイル形式です。');
                        }
                    } catch (error) {
                        alert('ファイルの読み込みに失敗しました。');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }, []);

            // 全データクリア
            const clearAllData = useCallback(() => {
                if (confirm('本当に全てのデータを削除しますか？\nこの操作は取り消せません。')) {
                    if (confirm('最終確認：全てのWebサイト情報が削除されます。よろしいですか？')) {
                        setUrlItems([]);
                        alert('全てのデータが削除されました。');
                    }
                }
            }, []);

            // URL追加機能（AI分析対応）
            const addUrlItem = useCallback(async (url, genre, priority = 0, comment = '', useAutoClassify = false) => {
                if (url && !urlItems.some(item => item.url === url)) {
                    try {
                        const metadata = await fetchUrlMetadata(url);
                        const finalGenre = useAutoClassify ? classifyGenre(url, metadata.title) : genre;
                        
                        const newItem = {
                            id: new Date().toISOString() + '_' + Math.random().toString(36).substr(2, 9),
                            url,
                            genre: finalGenre,
                            comment,
                            isRead: false,
                            rating: 0,
                            priority: priority,
                            createdAt: new Date().toISOString(),
                            title: metadata.title,
                            thumbnail: metadata.thumbnail,
                            domain: metadata.domain
                        };
                        setUrlItems(prevItems => [...prevItems, newItem]);
                    } catch (error) {
                        console.error('URLメタデータの取得に失敗:', error);
                        const newItem = {
                            id: new Date().toISOString() + '_' + Math.random().toString(36).substr(2, 9),
                            url,
                            genre,
                            comment,
                            isRead: false,
                            rating: 0,
                            priority: priority,
                            createdAt: new Date().toISOString(),
                            title: 'Webページ',
                            thumbnail: '🌐',
                            domain: ''
                        };
                        setUrlItems(prevItems => [...prevItems, newItem]);
                    }
                }
            }, [urlItems, fetchUrlMetadata, classifyGenre]);

            const deleteUrlItem = useCallback((id) => {
                setUrlItems(prevItems => prevItems.filter(item => item.id !== id));
            }, []);

            const toggleReadStatus = useCallback((id) => {
                setUrlItems(prevItems =>
                    prevItems.map(item =>
                        item.id === id ? { ...item, isRead: !item.isRead } : item
                    )
                );
            }, []);

            const setRating = useCallback((id, rating) => {
                setUrlItems(prevItems =>
                    prevItems.map(item =>
                        item.id === id ? { ...item, rating } : item
                    )
                );
            }, []);

            const setPriority = useCallback((id, priority) => {
                setUrlItems(prevItems =>
                    prevItems.map(item =>
                        item.id === id ? { ...item, priority } : item
                    )
                );
            }, []);

            const updateComment = useCallback((id, comment) => {
                setUrlItems(prevItems =>
                    prevItems.map(item =>
                        item.id === id ? { ...item, comment } : item
                    )
                );
            }, []);

            const moveUrlItem = useCallback((id, direction) => {
                setUrlItems(prevItems => {
                    const currentIndex = prevItems.findIndex(item => item.id === id);
                    
                    if (currentIndex === -1) {
                        return prevItems;
                    }
                    
                    const swapIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;

                    if (swapIndex < 0 || swapIndex >= prevItems.length) {
                        return prevItems;
                    }

                    const newItems = [...prevItems];
                    [newItems[currentIndex], newItems[swapIndex]] = [newItems[swapIndex], newItems[currentIndex]];
                    
                    return newItems;
                });
            }, []);

            const handleSort = useCallback((newSortBy) => {
                if (sortBy === newSortBy) {
                    setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
                } else {
                    setSortBy(newSortBy);
                    setSortDirection(newSortBy === 'created' ? 'desc' : 'asc');
                }
            }, [sortBy]);

            const genres = ['すべて', ...Array.from(new Set(urlItems.map(item => item.genre)))];
            
            const filteredAndSortedItems = useMemo(() => {
                let filtered = urlItems.filter(item => {
                    const matchesGenre = filterGenre === 'すべて' || item.genre === filterGenre;
                    const matchesSearch = searchQuery === '' || 
                        item.url.toLowerCase().includes(searchQuery.toLowerCase()) ||
                        item.genre.toLowerCase().includes(searchQuery.toLowerCase()) ||
                        (item.title && item.title.toLowerCase().includes(searchQuery.toLowerCase())) ||
                        (item.comment && item.comment.toLowerCase().includes(searchQuery.toLowerCase()));
                    const matchesReadStatus = readStatusFilter === 'すべて' ||
                        (readStatusFilter === '未読' && !item.isRead) ||
                        (readStatusFilter === '既読' && item.isRead);
                    
                    return matchesGenre && matchesSearch && matchesReadStatus;
                });

                if (sortBy !== 'created' || sortDirection !== 'desc') {
                    filtered.sort((a, b) => {
                        let comparison = 0;
                        
                        switch (sortBy) {
                            case 'priority':
                                comparison = b.priority - a.priority;
                                break;
                            case 'rating':
                                comparison = b.rating - a.rating;
                                break;
                            case 'created':
                                comparison = new Date(b.createdAt) - new Date(a.createdAt);
                                break;
                            case 'genre':
                                comparison = a.genre.localeCompare(b.genre, 'ja');
                                break;
                            default:
                                comparison = 0;
                        }
                        
                        return sortDirection === 'asc' ? comparison : -comparison;
                    });
                }

                return filtered;
            }, [urlItems, filterGenre, searchQuery, readStatusFilter, sortBy, sortDirection]);

            return (
                <div className="min-h-screen bg-slate-100 font-sans text-slate-800">
                    <header className="bg-white shadow-md">
                        <div className="max-w-4xl mx-auto py-6 px-4 sm:px-6 lg:px-8">
                            <div className="flex justify-between items-start">
                                <div className="flex-1">
                                    <h1 className="text-3xl font-bold tracking-tight text-slate-900">
                                        読みたいものリスト 🔥
                                    </h1>
                                    <p className="mt-2 text-slate-600">気になるWebサイトをリストアップして、管理しましょう。</p>
                                    <div className="mt-2 text-sm text-blue-600 bg-blue-50 p-2 rounded flex items-center">
                                        <span className="mr-2 px-2 py-1 bg-blue-100 text-blue-700 text-xs rounded-full">v2.8</span>
                                        👤 ユーザーID: {getUserId().substr(-8)} | 🕒 最終更新: {new Date().toLocaleString('ja-JP')}
                                    </div>
                                    <div className="mt-2 text-sm text-purple-600 bg-purple-50 p-2 rounded flex items-center">
                                        <span className="mr-2 px-2 py-1 bg-purple-100 text-purple-700 text-xs rounded-full">🤖 AI</span>
                                        ✨ AI内容分析機能で120文字の説明的タイトルを自動生成！
                                        {apiKey ? (
                                            <span className="ml-2 px-2 py-1 bg-green-100 text-green-700 text-xs rounded-full">設定済み</span>
                                        ) : (
                                            <span className="ml-2 px-2 py-1 bg-red-100 text-red-700 text-xs rounded-full">要API設定</span>
                                        )}
                                    </div>
                                </div>
                                <button
                                    onClick={() => setShowSettings(true)}
                                    className="ml-4 px-3 py-2 text-slate-600 hover:text-slate-900 hover:bg-slate-100 rounded-lg transition-colors flex items-center gap-1"
                                    title="API設定"
                                >
                                    ⚙️ API設定
                                </button>
                            </div>
                        </div>
                    </header>
                    
                    <main className="max-w-4xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
                        <div className="bg-white p-6 rounded-xl shadow-lg mb-8">
                            <h2 className="text-xl font-semibold mb-4 text-slate-700">新しいURLを追加</h2>
                            <UrlInput onAdd={addUrlItem} urlItems={urlItems} apiKey={apiKey} />
                        </div>

                        <div className="bg-white p-6 rounded-xl shadow-lg mb-8">
                            <div className="flex items-center gap-2 mb-2">
                                <SearchIcon className="h-5 w-5 text-slate-400" />
                                <h2 className="text-xl font-semibold text-slate-700">検索</h2>
                                <span className="px-2 py-1 bg-green-100 text-green-700 text-xs rounded-full">タイトル検索対応</span>
                            </div>
                            <input
                                type="text"
                                value={searchQuery}
                                onChange={(e) => setSearchQuery(e.target.value)}
                                placeholder="URL、タイトル、ジャンル、コメントで検索..."
                                className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500"
                            />
                            {searchQuery && (
                                <div className="mt-2 flex items-center justify-between">
                                    <p className="text-sm text-slate-600">
                                        「{searchQuery}」の検索結果: {filteredAndSortedItems.length}件
                                    </p>
                                    <button
                                        onClick={() => setSearchQuery('')}
                                        className="text-sm text-sky-600 hover:text-sky-800"
                                    >
                                        クリア
                                    </button>
                                </div>
                            )}
                        </div>

                        {urlItems.length > 0 && (
                            <div className="bg-white p-6 rounded-xl shadow-lg mb-8">
                                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
                                    <GenreFilter
                                        genres={genres}
                                        selectedGenre={filterGenre}
                                        onFilterChange={setFilterGenre}
                                    />
                                    <ReadStatusFilter
                                        selectedStatus={readStatusFilter}
                                        onFilterChange={setReadStatusFilter}
                                    />
                                </div>
                                
                                <div className="border-t pt-4">
                                    <div className="flex flex-wrap gap-2 mb-2">
                                        <span className="text-sm font-medium text-slate-700 mr-2 flex items-center">並び順:</span>
                                        <SortButton 
                                            sortBy="created" 
                                            currentSort={sortBy} 
                                            sortDirection={sortDirection}
                                            onClick={handleSort}
                                            label="追加日時"
                                        />
                                        <SortButton 
                                            sortBy="priority" 
                                            currentSort={sortBy} 
                                            sortDirection={sortDirection}
                                            onClick={handleSort}
                                            label="優先度"
                                        />
                                        <SortButton 
                                            sortBy="rating" 
                                            currentSort={sortBy} 
                                            sortDirection={sortDirection}
                                            onClick={handleSort}
                                            label="評価"
                                        />
                                        <SortButton 
                                            sortBy="genre" 
                                            currentSort={sortBy} 
                                            sortDirection={sortDirection}
                                            onClick={handleSort}
                                            label="ジャンル"
                                        />
                                    </div>
                                    <p className="text-xs text-slate-500 bg-yellow-50 p-2 rounded">
                                        💡 ヒント: 上下移動ボタンで手動で順番を変更できます。ソート機能を使用すると手動の順番はリセットされます。
                                    </p>
                                </div>
                                
                                <div className="mt-4 grid grid-cols-2 sm:grid-cols-4 gap-4 text-sm">
                                    <div className="text-center">
                                        <div className="font-semibold text-slate-900">{urlItems.length}</div>
                                        <div className="text-slate-600">総数</div>
                                    </div>
                                    <div className="text-center">
                                        <div className="font-semibold text-blue-600">{urlItems.filter(item => !item.isRead).length}</div>
                                        <div className="text-slate-600">未読</div>
                                    </div>
                                    <div className="text-center">
                                        <div className="font-semibold text-green-600">{urlItems.filter(item => item.isRead).length}</div>
                                        <div className="text-slate-600">既読</div>
                                    </div>
                                    <div className="text-center">
                                        <div className="font-semibold text-yellow-600">{filteredAndSortedItems.length}</div>
                                        <div className="text-slate-600">表示中</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        <UrlList
                            items={filteredAndSortedItems}
                            allItems={urlItems}
                            onDelete={deleteUrlItem}
                            onToggleRead={toggleReadStatus}
                            onSetRating={setRating}
                            onSetPriority={setPriority}
                            onMove={moveUrlItem}
                            onUpdateComment={updateComment}
                        />

                        <div className="bg-gradient-to-r from-green-50 to-blue-50 p-6 rounded-xl shadow-lg mt-8 border border-green-200">
                            <h2 className="text-xl font-semibold mb-4 text-slate-700 flex items-center">
                                🛠️ データ管理
                                <span className="ml-2 px-2 py-1 bg-green-100 text-green-700 text-xs rounded-full">v2.8</span>
                            </h2>
                            <div className="flex flex-wrap gap-3 mb-4">
                                <button
                                    onClick={exportData}
                                    className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 transition-colors flex items-center gap-2"
                                >
                                    📤 データをエクスポート
                                </button>
                                <button
                                    onClick={() => document.getElementById('importFile').click()}
                                    className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors flex items-center gap-2"
                                >
                                    📥 データをインポート
                                </button>
                                <button
                                    onClick={clearAllData}
                                    className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 transition-colors flex items-center gap-2"
                                >
                                    🗑️ 全データクリア
                                </button>
                                <input
                                    type="file"
                                    id="importFile"
                                    accept=".json"
                                    onChange={importData}
                                    style={{ display: 'none' }}
                                />
                            </div>
                            <div className="bg-white p-4 rounded-lg border border-blue-200">
                                <h3 className="text-sm font-medium text-blue-800 mb-2 flex items-center">
                                    💡 使い方ガイド
                                </h3>
                                <ul className="text-sm text-blue-700 space-y-1">
                                    <li><strong>🤖 AI分析</strong>：OpenAI APIで120文字の説明的タイトルを自動生成</li>
                                    <li><strong>📤 エクスポート</strong>：現在のデータをJSONファイルとして保存</li>
                                    <li><strong>📥 インポート</strong>：他のデバイスからエクスポートしたファイルを読み込み</li>
                                    <li><strong>🗑️ クリア</strong>：全てのデータを削除（取り消し不可）</li>
                                    <li><strong>🔍 検索</strong>：タイトル、URL、ジャンル、コメントで検索可能</li>
                                    <li><strong>⭐ 評価・優先度</strong>：5段階で評価・優先度を設定</li>
                                </ul>
                            </div>
                        </div>
                    </main>

                    {/* 設定モーダル */}
                    {showSettings && (
                        <SettingsModal
                            apiKey={apiKey}
                            onSave={saveApiKey}
                            onClose={() => setShowSettings(false)}
                        />
                    )}
                </div>
            );
        };

        // 設定モーダルコンポーネント
        const SettingsModal = ({ apiKey, onSave, onClose }) => {
            const [tempApiKey, setTempApiKey] = useState(apiKey);

            const handleSave = () => {
                onSave(tempApiKey);
                onClose();
                alert('設定を保存しました！');
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-white p-6 rounded-xl shadow-xl max-w-md w-full mx-4">
                        <h2 className="text-xl font-semibold mb-4 text-slate-800">⚙️ API設定</h2>
                        
                        <div className="mb-4">
                            <label className="block text-sm font-medium text-slate-700 mb-2">
                                OpenAI APIキー
                                <span className="ml-2 text-xs text-red-600">※AI分析機能に必要</span>
                            </label>
                            <input
                                type="password"
                                value={tempApiKey}
                                onChange={(e) => setTempApiKey(e.target.value)}
                                placeholder="sk-..."
                                className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500"
                            />
                            <p className="text-xs text-slate-500 mt-1">
                                APIキーは暗号化してローカルに保存されます
                            </p>
                        </div>

                        <div className="bg-blue-50 p-3 rounded-lg mb-4">
                            <h3 className="text-sm font-medium text-blue-800 mb-1">🤖 AI機能について</h3>
                            <ul className="text-xs text-blue-700 space-y-1">
                                <li>• URLの内容を分析して120文字の説明的タイトルを生成</li>
                                <li>• OpenAI GPT-3.5-turboを使用</li>
                                <li>• APIキー未設定時は従来のタイトル取得方法を使用</li>
                                <li>• データは外部に送信されず、ローカルで管理</li>
                            </ul>
                        </div>

                        <div className="flex gap-3">
                            <button
                                onClick={handleSave}
                                className="flex-1 px-4 py-2 bg-sky-600 text-white rounded-lg hover:bg-sky-700 transition-colors"
                            >
                                保存
                            </button>
                            <button
                                onClick={onClose}
                                className="flex-1 px-4 py-2 bg-slate-300 text-slate-700 rounded-lg hover:bg-slate-400 transition-colors"
                            >
                                キャンセル
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // UrlInputコンポーネント（AI分析対応）
        const UrlInput = ({ onAdd, urlItems, apiKey }) => {
            const [url, setUrl] = useState('');
            const [genre, setGenre] = useState('未分類');
            const [customGenre, setCustomGenre] = useState('');
            const [isCustomGenre, setIsCustomGenre] = useState(false);
            const [priority, setPriority] = useState(0);
            const [comment, setComment] = useState('');
            const [useAutoClassify, setUseAutoClassify] = useState(true);
            const [isLoading, setIsLoading] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('');

            const existingGenres = useMemo(() => {
                const genres = new Set(['未分類']);
                urlItems.forEach(item => {
                    if (item.genre && item.genre.trim()) {
                        genres.add(item.genre);
                    }
                });
                return Array.from(genres).sort();
            }, [urlItems]);

            const handleSubmit = async (e) => {
                e.preventDefault();
                if (url.trim()) {
                    setIsLoading(true);
                    try {
                        if (apiKey) {
                            setLoadingMessage('AI分析中...');
                        } else {
                            setLoadingMessage('URLを処理中...');
                        }
                        
                        const finalGenre = isCustomGenre && customGenre.trim() ? customGenre.trim() : genre;
                        await onAdd(url.trim(), finalGenre, priority, comment.trim(), useAutoClassify);
                        
                        setUrl('');
                        setGenre('未分類');
                        setCustomGenre('');
                        setIsCustomGenre(false);
                        setPriority(0);
                        setComment('');
                    } finally {
                        setIsLoading(false);
                        setLoadingMessage('');
                    }
                }
            };

            const handleGenreChange = (e) => {
                const value = e.target.value;
                if (value === 'custom') {
                    setIsCustomGenre(true);
                    setGenre('未分類');
                } else {
                    setIsCustomGenre(false);
                    setGenre(value);
                    setCustomGenre('');
                }
            };

            return (
                <form onSubmit={handleSubmit} className="space-y-4">
                    <div>
                        <label htmlFor="url-input" className="block text-sm font-medium text-slate-700 mb-2">
                            URL
                        </label>
                        <input
                            id="url-input"
                            type="url"
                            value={url}
                            onChange={(e) => setUrl(e.target.value)}
                            placeholder="https://example.com"
                            className="w-full px-3 py-2 border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500"
                            required
                            disabled={isLoading}
                        />
                    </div>
                    
                    {/* AI分析機能の状態表示 */}
                    {apiKey && (
                        <div className="flex items-center space-x-2 p-3 bg-green-50 rounded-lg border border-green-200">
                            <div className="text-green-600">🤖</div>
                            <div className="text-sm text-green-700">
                                <span className="font-medium">AI分析機能が有効です</span>
                                <div className="text-xs">URLの内容を分析して説明的なタイトルを生成します</div>
                            </div>
                        </div>
                    )}

                    <div className="flex items-center space-x-2 p-3 bg-purple-50 rounded-lg border border-purple-200">
                        <input
                            id="auto-classify"
                            type="checkbox"
                            checked={useAutoClassify}
                            onChange={(e) => setUseAutoClassify(e.target.checked)}
                            className="h-4 w-4 text-purple-600 focus:ring-purple-500 border-purple-300 rounded"
                            disabled={isLoading}
                        />
                        <label htmlFor="auto-classify" className="text-sm text-purple-700 flex items-center">
                            🤖 自動ジャンル分類を使用
                            <span className="ml-2 px-2 py-1 bg-purple-100 text-purple-700 text-xs rounded-full">機能</span>
                        </label>
                    </div>

                    {!useAutoClassify && (
                        <div>
                            <label htmlFor="genre-select" className="block text-sm font-medium text-slate-700 mb-2 flex items-center">
                                ジャンル
                                {existingGenres.length > 1 && (
                                    <span className="ml-2 px-2 py-1 bg-blue-100 text-blue-700 text-xs rounded-full">
                                        {existingGenres.length - 1}個の既存ジャンル
                                    </span>
                                )}
                            </label>
                            <select
                                id="genre-select"
                                value={isCustomGenre ? 'custom' : genre}
                                onChange={handleGenreChange}
                                className="w-full px-3 py-2 border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500"
                                disabled={isLoading}
                            >
                                {existingGenres.map((existingGenre) => (
                                    <option key={existingGenre} value={existingGenre}>
                                        {existingGenre}
                                    </option>
                                ))}
                                <option value="custom">+ 新しいジャンルを追加</option>
                            </select>
                            
                            {isCustomGenre && (
                                <input
                                    type="text"
                                    value={customGenre}
                                    onChange={(e) => setCustomGenre(e.target.value)}
                                    placeholder="新しいジャンル名を入力"
                                    className="w-full mt-2 px-3 py-2 border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500"
                                    autoFocus
                                    disabled={isLoading}
                                />
                            )}
                        </div>
                    )}

                    <div>
                        <label htmlFor="priority-select" className="block text-sm font-medium text-slate-700 mb-2 flex items-center">
                            優先度
                            <span className="ml-2 px-2 py-1 bg-red-100 text-red-700 text-xs rounded-full">0-5</span>
                        </label>
                        <select
                            id="priority-select"
                            value={priority}
                            onChange={(e) => setPriority(parseInt(e.target.value))}
                            className="w-full px-3 py-2 border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500"
                            disabled={isLoading}
                        >
                            <option value={0}>0 - 優先度なし</option>
                            <option value={1}>1 - 低</option>
                            <option value={2}>2 - やや低</option>
                            <option value={3}>3 - 中</option>
                            <option value={4}>4 - やや高</option>
                            <option value={5}>5 - 高</option>
                        </select>
                    </div>

                    <div>
                        <label htmlFor="comment-input" className="block text-sm font-medium text-slate-700 mb-2 flex items-center">
                            コメント・メモ
                            <span className="ml-2 px-2 py-1 bg-green-100 text-green-700 text-xs rounded-full">任意</span>
                        </label>
                        <textarea
                            id="comment-input"
                            value={comment}
                            onChange={(e) => setComment(e.target.value)}
                            placeholder="このサイトについてのメモやコメントを入力してください..."
                            rows="3"
                            className="w-full px-3 py-2 border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500 resize-vertical"
                            disabled={isLoading}
                        />
                    </div>
                    
                    <button
                        type="submit"
                        disabled={isLoading}
                        className={`w-full py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 transition-colors ${
                            isLoading 
                                ? 'bg-slate-400 text-white cursor-not-allowed'
                                : 'bg-sky-600 text-white hover:bg-sky-700'
                        }`}
                    >
                        {isLoading ? (
                            <span className="flex items-center justify-center">
                                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                {loadingMessage || '処理中...'}
                            </span>
                        ) : (
                            '追加'
                        )}
                    </button>
                </form>
            );
        };

        // GenreFilterコンポーネント
        const GenreFilter = ({ genres, selectedGenre, onFilterChange }) => {
            return (
                <div>
                    <label htmlFor="genre-filter" className="block text-sm font-medium text-slate-700 mb-2">
                        ジャンルで絞り込み
                    </label>
                    <select
                        id="genre-filter"
                        value={selectedGenre}
                        onChange={(e) => onFilterChange(e.target.value)}
                        className="w-full px-3 py-2 border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500"
                    >
                        {genres.map(genre => (
                            <option key={genre} value={genre}>{genre}</option>
                        ))}
                    </select>
                </div>
            );
        };

        // ReadStatusFilterコンポーネント
        const ReadStatusFilter = ({ selectedStatus, onFilterChange }) => {
            return (
                <div>
                    <label htmlFor="read-status-filter" className="block text-sm font-medium text-slate-700 mb-2">
                        未読・既読で絞り込み
                    </label>
                    <select
                        id="read-status-filter"
                        value={selectedStatus}
                        onChange={(e) => onFilterChange(e.target.value)}
                        className="w-full px-3 py-2 border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500"
                    >
                        <option value="すべて">すべて</option>
                        <option value="未読">未読のみ</option>
                        <option value="既読">既読のみ</option>
                    </select>
                </div>
            );
        };

        // SortButtonコンポーネント
        const SortButton = ({ sortBy, currentSort, sortDirection, onClick, label }) => {
            const isActive = currentSort === sortBy;
            const showArrow = isActive;
            
            return (
                <button
                    onClick={() => onClick(sortBy)}
                    className={`flex items-center gap-1 px-3 py-1 rounded-md text-sm font-medium transition-colors ${
                        isActive 
                            ? 'bg-sky-100 text-sky-700 border border-sky-300' 
                            : 'bg-slate-100 text-slate-600 hover:bg-slate-200 border border-slate-300'
                    }`}
                >
                    <span>{label}</span>
                    {showArrow && (
                        sortDirection === 'asc' ? 
                            <ArrowUpIcon className="h-3 w-3" /> : 
                            <ArrowDownIcon className="h-3 w-3" />
                    )}
                </button>
            );
        };

        // UrlListコンポーネント
        const UrlList = ({ items, allItems, onDelete, onToggleRead, onSetRating, onSetPriority, onMove, onUpdateComment }) => {
            if (items.length === 0) {
                return (
                    <div className="bg-white p-8 rounded-xl shadow-lg text-center">
                        <div className="text-slate-400 mb-4">
                            <svg className="mx-auto h-16 w-16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                            </svg>
                        </div>
                        <h3 className="text-lg font-medium text-slate-900 mb-2">
                            {allItems.length === 0 ? 'リストは空です' : '該当するアイテムがありません'}
                        </h3>
                        <p className="text-slate-500">
                            {allItems.length === 0 
                                ? '上部のフォームからURLを追加してください。'
                                : '検索条件やフィルターを変更してみてください。'
                            }
                        </p>
                    </div>
                );
            }

            return (
                <div className="space-y-3">
                    {items.map((item) => (
                        <UrlItem
                            key={item.id}
                            item={item}
                            allItems={allItems}
                            onDelete={onDelete}
                            onToggleRead={onToggleRead}
                            onSetRating={onSetRating}
                            onSetPriority={onSetPriority}
                            onMove={onMove}
                            onUpdateComment={onUpdateComment}
                        />
                    ))}
                </div>
            );
        };

        // UrlItemコンポーネント（コンパクト版）
        const UrlItem = ({ item, allItems, onDelete, onToggleRead, onSetRating, onSetPriority, onMove, onUpdateComment }) => {
            const [isEditingComment, setIsEditingComment] = useState(false);
            const [commentText, setCommentText] = useState(item.comment || '');
            
            const originalIndex = allItems.findIndex(originalItem => originalItem.id === item.id);
            const canMoveUp = originalIndex > 0;
            const canMoveDown = originalIndex < allItems.length - 1;

            const formatDate = (dateString) => {
                try {
                    const date = new Date(dateString);
                    return date.toLocaleDateString('ja-JP', {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                } catch {
                    return '不明';
                }
            };

            const handleCommentSave = () => {
                onUpdateComment(item.id, commentText);
                setIsEditingComment(false);
            };

            const handleCommentCancel = () => {
                setCommentText(item.comment || '');
                setIsEditingComment(false);
            };

            return (
                <div className={`bg-white rounded-lg shadow-md p-4 border-l-4 ${item.isRead ? 'border-green-500 bg-green-50' : 'border-sky-500'}`}>
                    <div className="flex justify-between items-start">
                        <div className="flex-1 min-w-0">
                            {/* タイトル行とジャンル・読み取り状況 */}
                            <div className="flex items-start gap-3 mb-2">
                                <div className="text-xl">{item.thumbnail || '🌐'}</div>
                                <div className="flex-1">
                                    <div className="flex items-center gap-2 mb-1">
                                        <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-800">
                                            {item.genre}
                                        </span>
                                        {item.isRead && (
                                            <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                                                既読
                                            </span>
                                        )}
                                        {item.priority > 0 && (
                                            <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
                                                優先度 {item.priority}
                                            </span>
                                        )}
                                    </div>
                                    {/* クリック可能なタイトル */}
                                    <a
                                        href={item.url}
                                        target="_blank"
                                        rel="noopener noreferrer"
                                        className="text-lg font-medium text-blue-600 hover:text-blue-800 hover:underline block mb-1 line-clamp-2"
                                    >
                                        {item.title || item.url}
                                    </a>
                                    {/* ドメイン表示 */}
                                    {item.domain && (
                                        <p className="text-sm text-slate-500 mb-2">📍 {item.domain}</p>
                                    )}
                                </div>
                            </div>
                            
                            {/* 優先度・評価・追加日時を1行に配置 */}
                            <div className="flex items-center gap-4 mb-3 text-sm">
                                <div className="flex items-center gap-1">
                                    <span className="text-slate-600">優先度:</span>
                                    <StarRating 
                                        rating={item.priority} 
                                        onRate={(priority) => onSetPriority(item.id, priority)}
                                        color="red"
                                        size="small"
                                    />
                                </div>
                                <div className="flex items-center gap-1">
                                    <span className="text-slate-600">評価:</span>
                                    <StarRating 
                                        rating={item.rating} 
                                        onRate={(rating) => onSetRating(item.id, rating)}
                                        color="yellow"
                                        size="small"
                                    />
                                </div>
                                <div className="flex items-center gap-1 text-slate-500">
                                    <CalendarIcon className="h-3 w-3" />
                                    <span>{formatDate(item.createdAt)}</span>
                                </div>
                            </div>
                            
                            {/* コメント表示・編集（コンパクト版） */}
                            {(item.comment || isEditingComment) && (
                                <div className="mt-2 p-2 bg-slate-50 rounded border">
                                    <div className="flex items-center justify-between mb-1">
                                        <span className="text-xs font-medium text-slate-600">💬 コメント</span>
                                        <button
                                            onClick={() => setIsEditingComment(!isEditingComment)}
                                            className="text-xs text-sky-600 hover:text-sky-800"
                                        >
                                            {isEditingComment ? 'キャンセル' : '編集'}
                                        </button>
                                    </div>
                                    {isEditingComment ? (
                                        <div className="space-y-1">
                                            <textarea
                                                value={commentText}
                                                onChange={(e) => setCommentText(e.target.value)}
                                                placeholder="コメントを入力してください..."
                                                rows="2"
                                                className="w-full px-2 py-1 border border-slate-300 rounded text-sm focus:outline-none focus:ring-1 focus:ring-sky-500 focus:border-sky-500 resize-vertical"
                                            />
                                            <div className="flex gap-1">
                                                <button
                                                    onClick={handleCommentSave}
                                                    className="px-2 py-1 bg-sky-600 text-white rounded text-xs hover:bg-sky-700"
                                                >
                                                    保存
                                                </button>
                                                <button
                                                    onClick={handleCommentCancel}
                                                    className="px-2 py-1 bg-slate-300 text-slate-700 rounded text-xs hover:bg-slate-400"
                                                >
                                                    キャンセル
                                                </button>
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="text-sm text-slate-600">
                                            {item.comment ? (
                                                <div className="whitespace-pre-wrap break-words">{item.comment}</div>
                                            ) : (
                                                <span className="text-slate-400 italic">コメントがありません</span>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                        
                        {/* 右側のボタン群 */}
                        <div className="flex flex-col gap-1 ml-4">
                            <div className="flex flex-col gap-1">
                                {canMoveUp ? (
                                    <button
                                        onClick={() => onMove(item.id, 'up')}
                                        className="p-1 text-white bg-blue-500 hover:bg-blue-600 rounded shadow-sm transition-all duration-200"
                                        title="上に移動"
                                    >
                                        <ArrowUpIcon className="h-3 w-3" />
                                    </button>
                                ) : (
                                    <div className="p-1 text-slate-300 bg-slate-100 rounded">
                                        <ArrowUpIcon className="h-3 w-3" />
                                    </div>
                                )}
                                {canMoveDown ? (
                                    <button
                                        onClick={() => onMove(item.id, 'down')}
                                        className="p-1 text-white bg-blue-500 hover:bg-blue-600 rounded shadow-sm transition-all duration-200"
                                        title="下に移動"
                                    >
                                        <ArrowDownIcon className="h-3 w-3" />
                                    </button>
                                ) : (
                                    <div className="p-1 text-slate-300 bg-slate-100 rounded">
                                        <ArrowDownIcon className="h-3 w-3" />
                                    </div>
                                )}
                            </div>
                            <div className="flex flex-col gap-1 mt-1">
                                <button
                                    onClick={() => onToggleRead(item.id)}
                                    className={`px-2 py-1 rounded text-xs font-medium ${
                                        item.isRead
                                            ? 'bg-slate-200 text-slate-700 hover:bg-slate-300'
                                            : 'bg-green-600 text-white hover:bg-green-700'
                                    }`}
                                >
                                    {item.isRead ? '未読' : '既読'}
                                </button>
                                <button
                                    onClick={() => onDelete(item.id)}
                                    className="px-2 py-1 bg-red-600 text-white rounded text-xs font-medium hover:bg-red-700"
                                >
                                    削除
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // StarRatingコンポーネント（サイズ対応）
        const StarRating = ({ rating, onRate, color = 'yellow', size = 'normal' }) => {
            const colorClasses = {
                yellow: {
                    active: 'text-yellow-400',
                    inactive: 'text-slate-300',
                    hover: 'hover:text-yellow-400'
                },
                red: {
                    active: 'text-red-400',
                    inactive: 'text-slate-300',
                    hover: 'hover:text-red-400'
                }
            };

            const sizeClasses = {
                normal: 'text-lg',
                small: 'text-sm'
            };

            const colors = colorClasses[color];
            const sizeClass = sizeClasses[size];

            return (
                <div className="flex gap-0.5">
                    {[1, 2, 3, 4, 5].map((star) => (
                        <button
                            key={star}
                            onClick={() => onRate(star)}
                            className={`${sizeClass} ${
                                star <= rating ? colors.active : colors.inactive
                            } ${colors.hover} transition-colors`}
                        >
                            ★
                        </button>
                    ))}
                </div>
            );
        };

        // アイコンコンポーネント
        const SearchIcon = ({ className }) => (
            <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
        );

        const CalendarIcon = ({ className }) => (
            <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 002 2z" />
            </svg>
        );

        const ArrowUpIcon = ({ className }) => (
            <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 15l7-7 7 7" />
            </svg>
        );

        const ArrowDownIcon = ({ className }) => (
            <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
            </svg>
        );

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
